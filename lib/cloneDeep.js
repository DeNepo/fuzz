function t(t, e) { return t === e || t != t && e != e } function e(e, n) { let { length: r } = e; for (; r--;)if (t(e[r][0], n)) return r; return -1 } class n { constructor(t) { let e = -1; const n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { const n = t[e]; this.set(n[0], n[1]) } } clear() { this.__data__ = [], this.size = 0 } delete(t) { const n = this.__data__, r = e(n, t); if (r < 0) return !1; return r == n.length - 1 ? n.pop() : n.splice(r, 1), --this.size, !0 } get(t) { const n = this.__data__, r = e(n, t); return r < 0 ? void 0 : n[r][1] } has(t) { return e(this.__data__, t) > -1 } set(t, n) { const r = this.__data__, o = e(r, t); return o < 0 ? (++this.size, r.push([t, n])) : r[o][1] = n, this } } class r { constructor(t) { let e = -1; const n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { const n = t[e]; this.set(n[0], n[1]) } } clear() { this.__data__ = Object.create(null), this.size = 0 } delete(t) { const e = this.has(t) && delete this.__data__[t]; return this.size -= e ? 1 : 0, e } get(t) { const e = this.__data__[t]; return "__lodash_hash_undefined__" === e ? void 0 : e } has(t) { return void 0 !== this.__data__[t] } set(t, e) { const n = this.__data__; return this.size += this.has(t) ? 0 : 1, n[t] = void 0 === e ? "__lodash_hash_undefined__" : e, this } } function o({ __data__: t }, e) { const n = t; return function (t) { const e = typeof t; return "string" === e || "number" === e || "symbol" === e || "boolean" === e ? "__proto__" !== t : null === t }(e) ? n["string" == typeof e ? "string" : "hash"] : n.map } class s { constructor(t) { let e = -1; const n = null == t ? 0 : t.length; for (this.clear(); ++e < n;) { const n = t[e]; this.set(n[0], n[1]) } } clear() { this.size = 0, this.__data__ = { hash: new r, map: new Map, string: new r } } delete(t) { const e = o(this, t).delete(t); return this.size -= e ? 1 : 0, e } get(t) { return o(this, t).get(t) } has(t) { return o(this, t).has(t) } set(t, e) { const n = o(this, t), r = n.size; return n.set(t, e), this.size += n.size == r ? 0 : 1, this } } class c { constructor(t) { const e = this.__data__ = new n(t); this.size = e.size } clear() { this.__data__ = new n, this.size = 0 } delete(t) { const e = this.__data__, n = e.delete(t); return this.size = e.size, n } get(t) { return this.__data__.get(t) } has(t) { return this.__data__.has(t) } set(t, e) { let r = this.__data__; if (r instanceof n) { const n = r.__data__; if (n.length < 199) return n.push([t, e]), this.size = ++r.size, this; r = this.__data__ = new s(n) } return r.set(t, e), this.size = r.size, this } } function i(t, e, n) { "__proto__" == e ? Object.defineProperty(t, e, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : t[e] = n } const u = Object.prototype.hasOwnProperty; function a(e, n, r) { const o = e[n]; u.call(e, n) && t(o, r) ? void 0 !== r || n in e || i(e, n, r) : 0 === r && 1 / r != 1 / o || i(e, n, r) } const l = "object" == typeof global && null !== global && global.Object === Object && global, f = "object" == typeof globalThis && null !== globalThis && globalThis.Object == Object && globalThis, b = "object" == typeof self && null !== self && self.Object === Object && self, h = f || l || b || Function("return this")(), _ = "object" == typeof exports && null !== exports && !exports.nodeType && exports, p = _ && "object" == typeof module && null !== module && !module.nodeType && module, y = p && p.exports === _ ? h.Buffer : void 0, j = y ? y.allocUnsafe : void 0; function d(t, e, n, r) { const o = !n; n || (n = {}); for (const s of e) { let e = r ? r(n[s], t[s], s, n, t) : void 0; void 0 === e && (e = t[s]), o ? i(n, s, e) : a(n, s, e) } return n } function g(t) { const e = new t.constructor(t.byteLength); return new Uint8Array(e).set(new Uint8Array(t)), e } const A = /\w*$/; const O = Symbol.prototype.valueOf; const m = Object.prototype.propertyIsEnumerable, w = Object.getOwnPropertySymbols; function x(t) { return null == t ? [] : (t = Object(t), w(t).filter(e => m.call(t, e))) } function z(t) { const e = []; for (; t;)e.push(...x(t)), t = Object.getPrototypeOf(Object(t)); return e } const v = Object.prototype.toString; function U(t) { return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : v.call(t) } function T(t) { return "object" == typeof t && null !== t } const I = "object" == typeof exports && null !== exports && !exports.nodeType && exports, S = I && "object" == typeof module && null !== module && !module.nodeType && module, B = S && S.exports === I ? h.Buffer : void 0, P = (B ? B.isBuffer : void 0) || (() => !1), E = /^(?:0|[1-9]\d*)$/; function F(t, e) { const n = typeof t; return !!(e = null == e ? 9007199254740991 : e) && ("number" === n || "symbol" !== n && E.test(t)) && t > -1 && t % 1 == 0 && t < e } const D = "object" == typeof exports && null !== exports && !exports.nodeType && exports, C = D && "object" == typeof module && null !== module && !module.nodeType && module, M = C && C.exports === D && l.process, N = (() => { try { const t = C && C.require && C.require("util").types; return t || M && M.binding && M.binding("util") } catch (t) { } })(), $ = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/, k = N && N.isTypedArray, q = k ? t => k(t) : t => T(t) && $.test(U(t)), L = Object.prototype.hasOwnProperty; function R(t, e) { const n = Array.isArray(t), r = !n && function (t) { return T(t) && "[object Arguments]" == U(t) }(t), o = !n && !r && P(t), s = !n && !r && !o && q(t), c = n || r || o || s, i = t.length, u = new Array(c ? i : 0); let a = c ? -1 : i; for (; ++a < i;)u[a] = "" + a; for (const n in t) !e && !L.call(t, n) || c && ("length" === n || F(n, i)) || u.push(n); return u } function V(t) { return null != (e = t) && "function" != typeof e && function (t) { return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991 }(e.length) ? R(t) : Object.keys(Object(t)); var e } function W(t) { const e = V(t); return Array.isArray(t) || e.push(...x(t)), e } function G(t) { const e = []; for (const n in t) e.push(n); return Array.isArray(t) || e.push(...z(t)), e } const H = Object.prototype; function J(t) { return "function" != typeof t.constructor || function (t) { const e = t && t.constructor; return t === ("function" == typeof e && e.prototype || H) }(t) ? {} : Object.create(Object.getPrototypeOf(t)) } function K(t) { const e = []; for (const n in t) e.push(n); return e } const Q = "[object Map]", X = "[object Set]", Y = {}; Y["[object Arguments]"] = Y["[object Array]"] = Y["[object ArrayBuffer]"] = Y["[object DataView]"] = Y["[object Boolean]"] = Y["[object Date]"] = Y["[object Float32Array]"] = Y["[object Float64Array]"] = Y["[object Int8Array]"] = Y["[object Int16Array]"] = Y["[object Int32Array]"] = Y[Q] = Y["[object Number]"] = Y["[object Object]"] = Y["[object RegExp]"] = Y[X] = Y["[object String]"] = Y["[object Symbol]"] = Y["[object Uint8Array]"] = Y["[object Uint8ClampedArray]"] = Y["[object Uint16Array]"] = Y["[object Uint32Array]"] = !0, Y["[object Error]"] = Y["[object WeakMap]"] = !1; const Z = Object.prototype.hasOwnProperty; function tt(t, e, n) { const r = t.constructor; switch (e) { case "[object ArrayBuffer]": return g(t); case "[object Boolean]": case "[object Date]": return new r(+t); case "[object DataView]": return function (t, e) { const n = e ? g(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.byteLength) }(t, n); case "[object Float32Array]": case "[object Float64Array]": case "[object Int8Array]": case "[object Int16Array]": case "[object Int32Array]": case "[object Uint8Array]": case "[object Uint8ClampedArray]": case "[object Uint16Array]": case "[object Uint32Array]": return function (t, e) { const n = e ? g(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.length) }(t, n); case Q: return new r; case "[object Number]": case "[object String]": return new r(t); case "[object RegExp]": return function (t) { const e = new t.constructor(t.source, A.exec(t)); return e.lastIndex = t.lastIndex, e }(t); case X: return new r; case "[object Symbol]": return o = t, Object(O.call(o)) }var o } function et(t, e, n, r, o, s) { let i; const u = 1 & e, l = 2 & e, f = 4 & e; if (n && (i = o ? n(t, r, o, s) : n(t)), void 0 !== i) return i; if (!function (t) { const e = typeof t; return null != t && ("object" === e || "function" === e) }(t)) return t; const b = Array.isArray(t), h = U(t); if (b) { if (i = function (t) { const { length: e } = t, n = new t.constructor(e); return e && "string" == typeof t[0] && Z.call(t, "index") && (n.index = t.index, n.input = t.input), n }(t), !u) return function (t, e) { let n = -1; const r = t.length; for (e || (e = new Array(r)); ++n < r;)e[n] = t[n]; return e }(t, i) } else { const e = "function" == typeof t; if (P(t)) return function (t, e) { if (e) return t.slice(); const n = t.length, r = j ? j(n) : new t.constructor(n); return t.copy(r), r }(t, u); if ("[object Object]" == h || "[object Arguments]" == h || e && !o) { if (i = l || e ? {} : J(t), !u) return l ? function (t, e) { return d(t, z(t), e) }(t, d(t, K(t), i)) : function (t, e) { return d(t, x(t), e) }(t, Object.assign(i, t)) } else { if (e || !Y[h]) return o ? t : {}; i = tt(t, h, u) } } s || (s = new c); const _ = s.get(t); if (_) return _; if (s.set(t, i), h == Q) return t.forEach((r, o) => { i.set(o, et(r, e, n, o, t, s)) }), i; if (h == X) return t.forEach(r => { i.add(et(r, e, n, r, t, s)) }), i; if (q(t)) return i; const p = b ? void 0 : (f ? l ? G : W : l ? K : V)(t); return function (t, e) { let n = -1; const r = t.length; for (; ++n < r && !1 !== e(t[n], n, t);); }(p || t, (r, o) => { p && (r = t[o = r]), a(i, o, et(r, e, n, o, t, s)) }), i } export default function (t) { return et(t, 5) }

// bundled from lodash using rollup

// import { terser } from "rollup-plugin-terser";

// export default {
//   input: 'cloneDeep.js',
//   output: {
//     dir: 'output',
//     format: 'es',
//     name: 'cloneDeep'
//   },

//   plugins: [terser()],
// };
